#!/bin/bash
set -euo pipefail

# === Opciones de línea de comandos ===
workdir="$PWD"
printsrcinfo=false
noarchive=false
skipchecksums=false
ver="n2026"

function version(){
	echo "$(basename $0) (nhopkg) $ver"
	echo "Copyright (C) 2007-2025 Carlos Sanchez <cargabsj175@gmail.com>."
	echo ""
	echo "This is free software; see the source for copying conditions."
	echo "There IS NO WARRANTY, to the extent permitted by law."
	exit 1
	}

while [[ $# -gt 0 ]]; do
    case "$1" in
        -D|--dir)
            if [[ -z "${2:-}" ]]; then
                echo "Error: $1 requiere un argumento." >&2
                exit 1
            fi
            workdir="$2"
            shift 2
            ;;
        --noarchive)
			noarchive=true
			shift
			;;
		--skipchecksums)
			skipchecksums=true
			shift
			;;
        --printsrcinfo)
            printsrcinfo=true
            shift
            ;;
        -h|--help)
			echo "$(basename $0) (nhopkg) $ver"
			echo ""
			echo "Pure bash tool to build PKGBUILD using nhopkg"
			echo ""
			echo "Usage: $(basename $0) [options]"
			echo ""
			echo "Options:"
			echo "-D, --dir <dir>  Change to directory <dir> before processing PKGBUILD"
			echo "-h, --help       Show this help message and exit"
			echo "-V, --version    Show version information and exit"
			echo "--noarchive      Do not create package archive"
			echo "--skipchecksums  Do not verify downloaded source checksums"
			echo "--printsrcinfo   Print the generated SRCINFO and exit"
			exit 1
			;;
		-V|--version)
			version
			;;
        *)
            echo "Opción desconocida: $1" >&2
            exit 1
            ;;
    esac
done

# Cambiar al directorio especificado
cd "$workdir"

# Directorios de trabajo (relativos al directorio de trabajo)
SRCDIR="$PWD/src"
readonly BUILDDIR="$PWD/build"
readonly PKGDIR="$PWD/pkg"
readonly PKGEXT=".pkg.tar.zst"
readonly CARCH="$(uname -m)"

# Colores
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m'

log() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
    exit 1
}

# Verificar PKGBUILD
[[ -f PKGBUILD ]] || error "PKGBUILD not found."

# Variables generales
PKGBUILDSHA256=$(sha256sum PKGBUILD | sed 's/ PKGBUILD//g')
BUILDDATE=$(date +%s)
PACKAGETYPE=$(cat PKGBUILD | grep package | sed 's/ {//g')

log "Cargando PKGBUILD..."
source PKGBUILD

# Verificar la condición
if [ "$PACKAGETYPE" != "package()" ]; then
    echo "Error: $(basename $0) only supports non-split PKGBUILD files..."
    exit 1
fi

##############################
# Funciones para metapaquetes
##############################
generate_srcinfo() {
    # Función auxiliar para imprimir array en formato SRCINFO
    print_array_field() {
        local field="$1"
        local var="$2"
        if ! eval '[[ -v '"$var"' ]]' 2>/dev/null; then
            return
        fi
        eval 'local values=("${'"$var"'[@]}")'
        for val in "${values[@]}"; do
            [[ -n "$val" ]] && echo "	$field = $val"
        done
    }
    cat <<EOF
pkgbase = ${pkgbase:-$pkgname}
	pkgdesc = $pkgdesc
	url = $url
EOF
	print_array_field "arch" "arch"
	cat <<EOF
	pkgver = $pkgver
	pkgrel = $pkgrel
	epoch = ${epoch:-1}
	packager = ${packager:-$(whoami)}
EOF
    # Campos opcionales
    print_array_field "license" "license"
    print_array_field "makedepends" "makedepends"
    print_array_field "depends" "depends"
    print_array_field "optdepends" "optdepends"
    print_array_field "provides" "provides"
    print_array_field "conflicts" "conflicts"
    print_array_field "noextract" "noextract"
    print_array_field "options" "options"
    print_array_field "replaces" "replaces"
    # Fuentes (simple)
    for src in "${source[@]}"; do
        echo "	source = $src"
    done
    print_array_field "sha256sums" "sha256sums"
    print_array_field "b2sums" "b2sums"
    # Fuentes (x86_64)
    for src in "${source_x86_64[@]}"; do
        echo "	source_x86_64 = $src"
    done
    print_array_field "sha256sums_x86_64" "sha256sums_x86_64"
    # Fuentes (aarch64)
    for src in "${source_aarch64[@]}"; do
        echo "	source_aarch64 = $src"
    done
    print_array_field "sha256sums_aarch64" "sha256sums_aarch64"
    cat <<EOF

pkgname = $pkgname
EOF
}

# Modo --printsrcinfo: imprimir y salir
if [[ "$printsrcinfo" == true ]]; then
    generate_srcinfo
    exit 0
fi

generate_pkginfo() {
	cat <<EOF
# Generated by $(basename $0)
pkgname = $pkgname
pkgbase = ${pkgbase:-$pkgname}
xdata = pkgtype=pkg
pkgver = $pkgver-$pkgrel
pkgdesc = $pkgdesc
url = $url
builddate = $BUILDDATE
packager = ${packager:-$(whoami)}
size = $(echo $(du -sb "$PKGDIR" | cut -f1))
arch = $(uname -m)
EOF

# Función auxiliar: escribe un campo que puede ser array o string
write_pkginfo_array_field() {
    local field_name="$1"
    local var_name="$2"

    # Si la variable no está definida, salir
    if ! eval '[[ -v '"$var_name"' ]]' >/dev/null 2>&1; then
        return
    fi

    # Extraer valores (funciona tanto para arrays como para strings)
    eval 'local _vals=("${'"$var_name"'[@]}")'

    for _v in "${_vals[@]}"; do
        # Saltar elementos vacíos
        [[ -n "$_v" ]] || continue
        # Si el campo es optdepends y el elemento contiene ':' o ' - ', dejar tal cual (ej: "pkg: descripción")
        echo "$field_name = $_v" >> "$PKGDIR/.PKGINFO"
    done
}

# Campos en el orden deseado por pacman (salteables si no existen)
# license (puede ser array o string)
write_pkginfo_array_field "license" "license"
# depends
write_pkginfo_array_field "depend" "depends"
# optdepends (opcional)
write_pkginfo_array_field "optdepend" "optdepends"
# makedepends (opcional)
write_pkginfo_array_field "makedepend" "makedepends"
# provides, conflicts, replaces (cada uno opcional)
write_pkginfo_array_field "provides" "provides"
write_pkginfo_array_field "conflicts" "conflicts"
write_pkginfo_array_field "replaces" "replaces"
	}

generate_pkgbuild() {
	cat  <<EOF
format = 2
pkgname = $pkgname
pkgbase = ${pkgbase:-$pkgname}
pkgver = $pkgver-$pkgrel
pkgarch = $(uname -m)
pkgbuild_sha256sum = $PKGBUILDSHA256
packager = ${packager:-$(whoami)}
builddate = $BUILDDATE
builddir = $workdir
startdir = $workdir
buildtool = $(basename $0)
buildtoolver = $ver
buildenv = !distcc
buildenv = color
buildenv = !ccache
buildenv = check
buildenv = !sign
options = strip
options = docs
options = !libtool
options = !staticlibs
options = emptydirs
options = zipman
options = purge
options = debug
options = lto
EOF
}

# Validar metadatos básicos
[[ -z ${pkgname:-} ]] && error "pkgname no definido."
[[ -z ${pkgver:-} ]] && error "pkgver no definido."
[[ -z ${pkgrel:-} ]] && error "pkgrel no definido."

readonly pkgfile="${pkgname}-${pkgver}-${pkgrel}-${CARCH}${PKGEXT}"

# Limpiar entorno
log "Limpiando directorios anteriores..."
rm -rf "$SRCDIR" "$BUILDDIR" "$PKGDIR"
mkdir -p "$SRCDIR" "$BUILDDIR" "$PKGDIR"

# ============================
# FUNCIÓN: verificar checksums
# ============================
# Verifica sha256, sha512 o b2 (blake2b) para el archivo dado.
# Usa arrays declaradas en PKGBUILD (sha256sums, sha512sums, b2sums,
# y sus variantes por arquitectura sha256sums_x86_64, etc.)
#
# Recibe:
#   $1 -> ruta completa del archivo en SRCDIR (o directo si es local)
#   $2 -> la entrada original de source (ej: "foo.tar.gz" o "name::https://...")
verify_checksum() {
    local filepath="$1"
    local srcentry="$2"

    # Si se pidió saltar verificaciones
    if [[ "$skipchecksums" == true ]]; then
        log "Saltando verificación de checksums para $filepath (opción --skipchecksums)"
        return 0
    fi

    # Si no existe el archivo regular (por ejemplo un repositorio clonado -> directorio), saltar
    if [[ ! -f "$filepath" ]]; then
        log "No es un fichero regular, saltando checksum: $filepath"
        return 0
    fi

    # Determinar el índice de la entrada dentro de la(s) arrays de source.
    local idx=-1
    local srcarray=""
    # Buscar en source[]
    if [[ -v source ]]; then
        for i in "${!source[@]}"; do
            if [[ "${source[$i]}" == "$srcentry" ]]; then
                idx=$i
                srcarray="source"
                break
            fi
        done
    fi
    # Si no encontrado, buscar en source_x86_64 o source_aarch64 si aplicable
    if [[ $idx -eq -1 && "$CARCH" == "x86_64" && -v source_x86_64 ]]; then
        for i in "${!source_x86_64[@]}"; do
            if [[ "${source_x86_64[$i]}" == "$srcentry" ]]; then
                idx=$i
                srcarray="source_x86_64"
                break
            fi
        done
    fi
    if [[ $idx -eq -1 && "$CARCH" == "aarch64" && -v source_aarch64 ]]; then
        for i in "${!source_aarch64[@]}"; do
            if [[ "${source_aarch64[$i]}" == "$srcentry" ]]; then
                idx=$i
                srcarray="source_aarch64"
                break
            fi
        done
    fi

    # Si no se encontró la entrada, informar y omitir verificación
    if [[ $idx -eq -1 ]]; then
        log "No se encontró la entrada correspondiente en arrays source[] para: $srcentry — omitiendo checksum."
        return 0
    fi

    # Obtener suma esperada (priorizar arrays por arquitectura cuando corresponda)
    local expected=""
    # helper para obtener elemento seguro
    _arr_get() {
        local arrname="$1"; local pos="$2"
        if eval '[[ -v '"$arrname"' ]]' 2>/dev/null; then
            eval "local -a __a=(\"\${${arrname}[@]}\")"
            if [[ $pos -ge 0 && $pos -lt ${#__a[@]} ]]; then
                echo "${__a[$pos]}"
                return 0
            fi
        fi
        return 1
    }

    if [[ "${srcarray}" == "source_x86_64" ]]; then
        # primero las sums específicas de x86_64
        expected="$(_arr_get sha256sums_x86_64 "$idx")" || true
        if [[ -z "$expected" ]]; then expected="$(_arr_get sha512sums_x86_64 "$idx")" || true; fi
        if [[ -z "$expected" ]]; then expected="$(_arr_get b2sums_x86_64 "$idx")" || true; fi

        # fallback a genérico si no hay específica
        if [[ -z "$expected" ]]; then
            expected="$(_arr_get sha256sums "$idx")" || true
            if [[ -z "$expected" ]]; then expected="$(_arr_get sha512sums "$idx")" || true; fi
            if [[ -z "$expected" ]]; then expected="$(_arr_get b2sums "$idx")" || true; fi
        fi

    elif [[ "${srcarray}" == "source_aarch64" ]]; then
        # primero las sums específicas de aarch64
        expected="$(_arr_get sha256sums_aarch64 "$idx")" || true
        if [[ -z "$expected" ]]; then expected="$(_arr_get sha512sums_aarch64 "$idx")" || true; fi
        if [[ -z "$expected" ]]; then expected="$(_arr_get b2sums_aarch64 "$idx")" || true; fi

        # fallback a genérico si no hay específica
        if [[ -z "$expected" ]]; then
            expected="$(_arr_get sha256sums "$idx")" || true
            if [[ -z "$expected" ]]; then expected="$(_arr_get sha512sums "$idx")" || true; fi
            if [[ -z "$expected" ]]; then expected="$(_arr_get b2sums "$idx")" || true; fi
        fi

    else
        # Caso por defecto: arrays genéricos
        expected="$(_arr_get sha256sums "$idx")" || true
        if [[ -z "$expected" ]]; then expected="$(_arr_get sha512sums "$idx")" || true; fi
        if [[ -z "$expected" ]]; then expected="$(_arr_get b2sums "$idx")" || true; fi
    fi

    # Si no hay suma esperada o es "SKIP", saltar
    if [[ -z "$expected" || "$expected" == "SKIP" || "$expected" == $'SKIP\n' ]]; then
        log "No hay checksum declarado (o es SKIP) para $filepath — se omite verificación."
        return 0
    fi

    # Normalizar expected (puede venir con espacios)
    expected="$(echo -n "$expected" | tr -d '[:space:]')"

    # Calcular sumas disponibles
    local computed=""
    if command -v sha256sum >/dev/null 2>&1; then
        computed="$(sha256sum "$filepath" | awk '{print $1}')"
        if [[ "$computed" == "$expected" ]]; then
            log "sha256 OK: $(basename "$filepath")"
            return 0
        fi
    fi

    if command -v sha512sum >/dev/null 2>&1; then
        computed="$(sha512sum "$filepath" | awk '{print $1}')"
        if [[ "$computed" == "$expected" ]]; then
            log "sha512 OK: $(basename "$filepath")"
            return 0
        fi
    fi

    # b2sum (blake2b)
    if command -v b2sum >/dev/null 2>&1; then
        computed="$(b2sum "$filepath" | awk '{print $1}')"
        if [[ "$computed" == "$expected" ]]; then
            log "b2 (blake2b) OK: $(basename "$filepath")"
            return 0
        fi
    fi

    # Si llegamos acá, ninguna coincide
    error "Checksum mismatch para $(basename "$filepath"). Esperado: $expected. Computado: $computed"
}

# === FUNCIÓN: descargar o copiar fuente ===
download_source() {
    local src="$1"
    local filename url

    # Si usa alias con '::', separar el nombre local y la URL real
    if [[ "$src" == *::* ]]; then
        filename="${src%%::*}"   # parte antes de '::'
        url="${src#*::}"         # parte después de '::'
    else
        filename="${src##*/}"    # por defecto, tomar el nombre del archivo de la URL
        url="$src"
    fi

    # Si no hay protocolo, es archivo local
    if [[ "$url" != *://* ]]; then
        [[ -f "$url" ]] || error "Archivo local no encontrado: $url"
        log "Copiando archivo local: $url → $filename"
        cp "$url" "$SRCDIR/$filename"
        # Verificar checksum del archivo copiado (si aplica)
        verify_checksum "$SRCDIR/$filename" "$src"
        return
    fi

    # Descarga vía HTTPS
    if [[ "$url" == http*://* ]]; then
        log "Descargando: $url → $filename"
        if command -v curl >/dev/null; then
            curl -Lf -o "$SRCDIR/$filename" "$url"
        elif command -v wget >/dev/null; then
            wget -O "$SRCDIR/$filename" "$url"
        else
            error "Necesitas curl o wget para descargar."
        fi
	# Verificar checksum del archivo descargado (si aplica)
	    verify_checksum "$SRCDIR/$filename" "$src"
    # Repositorios Git
    elif [[ "$url" == git+https://* ]]; then
        local full_url="${url#git+}"
        # url_base = parte antes de '#' (el repo real)
        local url_base="${full_url%%#*}"
        local fragment="${full_url#*#}"
        # repo_name extraído del url_base para evitar fragmentos como '#tag=...'
        local repo_name="${url_base##*/}"
        repo_name="${repo_name%.git}"

        if [[ "$fragment" == tag=* ]]; then
            local tag="${fragment#tag=}"
            log "Clonando etiqueta '$tag' de: $url_base"
            git clone --depth=1 --branch "$tag" "$url_base" "$SRCDIR/$repo_name"
        elif [[ "$fragment" == branch=* ]]; then
            local branch="${fragment#branch=}"
            log "Clonando rama '$branch' de: $url_base"
            git clone --depth=1 --branch "$branch" "$url_base" "$SRCDIR/$repo_name"
        else
            log "Clonando repositorio por defecto: $url_base"
            git clone --depth=1 "$url_base" "$SRCDIR/$repo_name"
        fi
    else
        error "Fuente no soportada: $src (solo local, http://, https://, git+https://)"
    fi
}

# === FUNCIÓN: extraer archivos comprimidos ===
extract_sources() {
    local extracted=false
    local -a skiplist
    local -a files

    # Asegurar SRCDIR por defecto (igual que makepkg)
    SRCDIR="${SRCDIR:-${PWD}/src}"
    mkdir -p "$SRCDIR"

    # Si noextract está definido, guardamos los nombres a omitir
    if [[ -v noextract && ${#noextract[@]} -gt 0 ]]; then
        skiplist=( "${noextract[@]}" )
    fi

    # Tomar "foto" de los archivos que hay ahora en SRCDIR para evitar procesar artefactos creados durante la extracción
    # Usamos nullglob en una subshell para evitar cambiar el shell globalmente
    readarray -t files < <(
        bash -c 'shopt -s nullglob; for f in "$1"/*; do printf "%s\n" "$f"; done' -- "$SRCDIR"
    )

    for f in "${files[@]}"; do
        [[ -e "$f" ]] || continue
        local filename=$(basename "$f")

        # Sólo procesar archivos regulares (evitar directorios)
        if [[ ! -f "$f" ]]; then
            log "Saltando $filename (no es archivo regular)"
            continue
        fi

        # Omitir si está en noextract[]
        if [[ " ${skiplist[*]} " == *" ${filename} "* ]]; then
            log "Omitiendo extracción de $filename (noextract)"
            continue
        fi

        case "$f" in
            *.tar.gz|*.tgz)
                log "Extrayendo $filename"
                tar -xzf "$f" -C "$SRCDIR" || { log "ERROR: falló tar -xzf $filename"; return 1; }
                extracted=true
                ;;
            *.tar.xz|*.txz)
                log "Extrayendo $filename"
                tar -xJf "$f" -C "$SRCDIR" || { log "ERROR: falló tar -xJf $filename"; return 1; }
                extracted=true
                ;;
            *.tar.bz2|*.tbz2)
                log "Extrayendo $filename"
                tar -xjf "$f" -C "$SRCDIR" || { log "ERROR: falló tar -xjf $filename"; return 1; }
                extracted=true
                ;;
            *.tar.zst)
                log "Extrayendo $filename"
                if ! command -v zstd >/dev/null 2>&1; then
                    log "ERROR: zstd no está disponible para descomprimir $filename"
                    return 1
                fi
                zstd -dc "$f" | tar -xf - -C "$SRCDIR" || { log "ERROR: falló descompresión zstd|tar para $filename"; return 1; }
                extracted=true
                ;;
            *.zip)
                log "Extrayendo $filename"
                if ! command -v unzip >/dev/null 2>&1; then
                    log "ERROR: unzip no está disponible para descomprimir $filename"
                    return 1
                fi
                unzip -q "$f" -d "$SRCDIR" || { log "ERROR: falló unzip $filename"; return 1; }
                extracted=true
                ;;
            *)
                log "Saltando $filename (tipo desconocido o no comprimido)"
                ;;
        esac
    done

    if [[ "$extracted" == false ]]; then
        log "No se extrajeron archivos (todos estaban en noextract o no eran comprimidos)."
    else
        # Mostrar árbol resultante para facilitar debugging (igual que makepkg suele listar)
        #log "Contenido de $SRCDIR tras la extracción:"
        #find "$SRCDIR" -maxdepth 3 -mindepth 1 -print || true
        echo ""
    fi
}


# === PROCESO PRINCIPAL ===

log "Descargando fuentes..."
# Iterar sobre source[]
if [[ -v source && ${#source[@]} -gt 0 ]]; then
    for src in "${source[@]}"; do
        download_source "$src"
    done
fi

# Iterar sobre source_x86_64[]
if [[ "$CARCH" == "x86_64" && -v source_x86_64 && ${#source_x86_64[@]} -gt 0 ]]; then
    for src in "${source_x86_64[@]}"; do
        download_source "$src"
    done
fi

# Iterar sobre source_aarch64[]
if [[ "$CARCH" == "aarch64" && -v source_aarch64 && ${#source_aarch64[@]} -gt 0 ]]; then
    for src in "${source_aarch64[@]}"; do
        download_source "$src"
    done
fi

extract_sources

# Ejecutar prepare()
if declare -f prepare >/dev/null; then
    log "Ejecutando prepare()..."
    (
        export srcdir="$SRCDIR"
        export pkgdir="$PKGDIR"
        export startdir="$PWD"
        cd "$SRCDIR"
        prepare
    )
fi

# Ejecutar build()
if declare -f build >/dev/null; then
    log "Ejecutando build()..."
    (
        export srcdir="$SRCDIR"
        export pkgdir="$PKGDIR"
        export startdir="$PWD"
        cd "$BUILDDIR"
        # Enlazar fuentes
        for item in "$SRCDIR"/*; do
            [[ -e "$item" ]] || continue
            ln -sf "$item" .
        done
        build
    )
else
    log "No se definió build(), saltando compilación (posiblemente paquete binario precompìlado)."
fi

# Ejecutar package()
if declare -f package >/dev/null; then
    log "Ejecutando package()..."

    # Si existe build(), usar $BUILDDIR, si no, usar $SRCDIR
    pkg_context="$BUILDDIR"
    if ! declare -f build >/dev/null; then
        pkg_context="$SRCDIR"
    fi

    (
        export srcdir="$SRCDIR"
        export pkgdir="$PKGDIR"
        export startdir="$PWD"
        cd "$pkg_context"
        package
    )
else
    error "Función package() no definida en PKGBUILD."
fi


# Metadatos mínimos (formato compatible con pacman, sin makedepends)
log "Generando metadatos (.PKGINFO)..."
generate_pkginfo > "$PKGDIR/.PKGINFO"

log "Generando metadatos (.BUILDINFO)..."
generate_pkgbuild > "$PKGDIR/.BUILDINFO"


# .MTREE (mejor compatibilidad con pacman)
if command -v bsdtar >/dev/null; then
    log "Generando .MTREE..."
    (cd "$PKGDIR" && bsdtar -czf .MTREE --format=mtree --options='!all,use-set,uid,gid,mode,time,size,sha256,link' . 2>/dev/null)
else
    log "Advertencia: bsdtar no encontrado. El paquete no tendrá .MTREE."
fi


if [[ "$noarchive" == true ]]; then
    log "Opción --noarchive activada: se omite la creación del paquete."
    log "${GREEN}Build completado sin generar .pkg.tar.zst${NC}"
    exit 0
fi

# Empaquetar
log "Creando paquete: $pkgfile"
if command -v bsdtar >/dev/null; then
    ( cd "$PKGDIR" && \
      find . -mindepth 1 -maxdepth 1 -printf '%P\0' | \
      bsdtar -c --zstd -f "$workdir/$pkgfile" --null -T - ) || {
        log "Error: falló bsdtar"
        exit 1
    }
else
    ( cd "$PKGDIR" && \
      find . -mindepth 1 -maxdepth 1 -printf '%P\0' | \
      tar -c --null -T - | zstd -o "$workdir/$pkgfile" ) || {
        log "Error: falló tar + zstd"
        exit 1
    }
fi

log "${GREEN}¡Paquete creado con éxito!${NC} -> $pkgfile"
