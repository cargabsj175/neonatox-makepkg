#!/bin/bash
set -euo pipefail

# === Opciones de línea de comandos ===
workdir="$PWD"
printsrcinfo=false
noarchive=false
skipchecksums=false
# === Si esta dentro de nhopkg usar la version de nhopkg ===
if [ -z "${NHOPKG_VERSION+x}" ]; then
	ver="n2026"
else
	ver="$NHOPKG_VERSION"
fi

function license(){
	echo "$(basename $0) $ver (makepkg)"
	echo "Copyright (C) 2007-2025 Carlos Sanchez <cargabsj175@gmail.com>."
	echo ""
	echo "This is free software; see the source for copying conditions."
	echo "There IS NO WARRANTY, to the extent permitted by law."
	exit 1
	}

while [[ $# -gt 0 ]]; do
    case "$1" in
        -D|--dir)
            if [[ -z "${2:-}" ]]; then
                echo "Error: $1 requiere un argumento." >&2
                exit 1
            fi
            workdir="$2"
            shift 2
            ;;
        --noarchive)
			noarchive=true
			shift
			;;
		--skipchecksums)
			skipchecksums=true
			shift
			;;
        --printsrcinfo)
            printsrcinfo=true
            shift
            ;;
        -h|--help)
			echo "$(basename $0) $ver (makepkg)"
			echo ""
			echo "Pure bash tool to build PKGBUILD using nhopkg"
			echo ""
			echo "Usage: $(basename $0) [options]"
			echo ""
			echo "Options:"
			echo "-D, --dir <dir>  Change to directory <dir> before processing PKGBUILD"
			echo "-h, --help       Show this help message and exit"
			echo "-V, --version    Show version information and exit"
			echo "--noarchive      Do not create package archive"
			echo "--skipchecksums  Do not verify downloaded source checksums"
			echo "--printsrcinfo   Print the generated SRCINFO and exit"
			exit 1
			;;
		-V|--version)
			license
			;;
        *)
            echo "Opción desconocida: $1" >&2
            exit 1
            ;;
    esac
done

# Cambiar al directorio especificado
cd "$workdir"

# Directorios de trabajo (relativos al directorio de trabajo)
SRCDIR="$PWD/src"
BUILDDIR="$PWD/build"
PKGDIR="$PWD/pkg"
PKGEXT=".pkg.tar.zst"

# Colores
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m'

log() {
    echo -e "${BLUE}\t**INFO:${NC} $1"
}

error() {
    echo -e "${RED}\t**ERROR:${NC} $1" >&2
    exit 1
}

# Verificar PKGBUILD
[[ -f PKGBUILD ]] || error "PKGBUILD not found."

# Variables generales
PKGBUILDSHA256=$(sha256sum PKGBUILD | sed 's/ PKGBUILD//g')
BUILDDATE=$(date +%s)
# Limitacion temporal en cueanto de desarrolla el soporte para paquetes Split
PACKAGETYPE=$(cat PKGBUILD | grep "package()" | sed 's/ {//g') 
## Basada en la configuracion por defecto del makepkg original
CARCH="$(uname -m)"
CHOST="$(echo "$MACHTYPE")"
BUILDENV=(!distcc color !ccache check !sign)
OPTIONS=(strip docs !libtool !staticlibs emptydirs zipman purge debug lto)

# Cargando PKGBUILD...
source PKGBUILD

# Verificar la condición
if [ "$PACKAGETYPE" != "package()" ]; then
    error "$(basename $0) only supports non-split PKGBUILD files..."
    exit 1
fi

SPLITPACKAGE=""
# 1) Si hay función package() definida -> paquete simple
if declare -f package >/dev/null 2>&1; then
    SPLITPACKAGE=""
else
    # 2) Si hay funciones package_<name> ya declaradas -> tomar nombres
    #    (esto cubre PKGBUILD que definen package_... literalmente)
    mapfile -t _pkgfuncs < <(declare -F | awk '{print $3}' | grep -E '^package_' || true)
    if [[ ${#_pkgfuncs[@]} -gt 0 ]]; then
        # Extraer sufijos "package_foo" -> "foo"
        for f in "${_pkgfuncs[@]}"; do
            SPLITPACKAGE+=" ${f#package_}"
        done
    else
        # 3) Si pkgname es un array con más de 1 elemento -> split package
        if eval '[[ $(declare -p pkgname 2>/dev/null) =~ "declare -a" ]]' && [[ "${#pkgname[@]}" -gt 1 ]]; then
            # expandir los nombres tal como quedaron tras source PKGBUILD
            for p in "${pkgname[@]}"; do
                SPLITPACKAGE+=" $p"
            done
        else
            # 4) Fallback: buscar literal "package_" en el PKGBUILD (por si usan defs textuales)
            if grep -q -E '^[[:space:]]*package_[A-Za-z0-9_.-]*\(\)' PKGBUILD 2>/dev/null; then
                mapfile -t _lines < <(grep -E '^[[:space:]]*package_[A-Za-z0-9_.-]*\(\)' PKGBUILD | sed -E 's/^[[:space:]]*package_([A-Za-z0-9_.-]*)\(\).*/\1/')
                for p in "${_lines[@]}"; do
                    SPLITPACKAGE+=" $p"
                done
            else
                SPLITPACKAGE=""
            fi
        fi
    fi
fi
# trim leading spaces
SPLITPACKAGE="${SPLITPACKAGE#"${SPLITPACKAGE%%[![:space:]]*}"}"

##############################
# Funciones para crear archivos de metadatos
##############################
	# Función auxiliar para imprimir array en formato SRCINFO
    print_array_field() {
        local field="$1"
        local var="$2"
        if ! eval '[[ -v '"$var"' ]]' 2>/dev/null; then
            return
        fi
        eval 'local values=("${'"$var"'[@]}")'
        for val in "${values[@]}"; do
            [[ -n "$val" ]] && echo "$field = $val"
        done
    }
#####
# Generar .SRCINFO
#####
generate_srcinfo() {
# Inicio del archivo .SRCINFO
    cat <<EOF
pkgbase = ${pkgbase:-$pkgname}
EOF
	if [ -n "${pkgdesc+x}" ]; then
    cat <<EOF
	pkgdesc = $pkgdesc
EOF
	fi
	cat <<EOF
	pkgver = $pkgver
	pkgrel = $pkgrel
EOF
	cat <<EOF
	url = $url
EOF
	print_array_field "	arch" "arch"
	print_array_field "	groups" "groups"
	if [ -n "${epoch+x}" ]; then
    cat <<EOF
	epoch = $epoch
EOF
	fi
	if [ -n "${packager+x}" ]; then
	cat <<EOF
	packager = ${packager:-$(echo "Unknow Packager")}
EOF
	fi
    # Campos opcionales
    print_array_field "	license" "license"
    print_array_field "	makedepends" "makedepends"
    print_array_field "	depends" "depends"
    print_array_field "	optdepends" "optdepends"
    print_array_field "	provides" "provides"
    print_array_field "	conflicts" "conflicts"
    print_array_field "	noextract" "noextract"
    print_array_field "	replaces" "replaces"
    print_array_field "	options" "options"
    # Fuentes (simple)
    for src in "${source[@]}"; do
        echo "	source = $src"
    done
    print_array_field "	sha512sums" "sha512sums"
    print_array_field "	sha256sums" "sha256sums"
    print_array_field "	b2sums" "b2sums"
    # Fuentes (x86_64)
    for src in "${source_x86_64[@]}"; do
        echo "	source_x86_64 = $src"
    done
    print_array_field "sha256sums_x86_64" "sha256sums_x86_64"
    # Fuentes (aarch64)
    for src in "${source_aarch64[@]}"; do
        echo "	source_aarch64 = $src"
    done
    print_array_field "sha256sums_aarch64" "sha256sums_aarch64"
    
    echo ""
    
# Iteramos si es un paquete split para completar el SRCINFO
############################################################

if [ "$SPLITPACKAGE" != "" ]; then
	if [ -n "${pkgdesc+x}" ]; then
	# Guardamos pkgdesc para que no se acumule
	origdesc=$pkgdesc
	fi
	for package in $SPLITPACKAGE;do
	echo "pkgname = $package"
	
	# Definimos la descripcion tanto si es pkgdesc o pkgdesc+
	##########################################################
	# Buscar asignación no acumulativa: pkgdesc=
	func_block=$(awk "/^package_$package\(\) \{/,/^}/" PKGBUILD)
	# Buscar asignación simple: pkgdesc=
	if pkgdesc_line=$(echo "$func_block" | grep -E '^[[:space:]]*pkgdesc='); then
		# Extraer el valor después del '=' y limpiar comillas
		pkgdesc_value=$(echo "$pkgdesc_line" | sed -E "s/^[[:space:]]*pkgdesc=[\"']?//; s/[\"']?[[:space:]]*$//")
		echo "	pkgdesc = ${pkgdesc_value:-$origdesc}"
	else
		pkgdesc_value=""
		#echo "	pkgdesc = $origdesc"
	fi

	# Buscar asignación acumulativa: pkgdesc+=
	if pkgdesc_plus_line=$(echo "$func_block" | grep -E '^[[:space:]]*pkgdesc\+='); then
		# Extraer el valor después del '+=' y limpiar comillas
		pkgdesc_plus_value=$(echo "$pkgdesc_plus_line" | sed -E "s/^[[:space:]]*pkgdesc\+=[\"']?//; s/[\"']?[[:space:]]*$//")
		cpkgdesc=$origdesc$pkgdesc_plus_value
		echo "	pkgdesc = ${cpkgdesc:-$origdesc}"
	else
		pkgdesc_plus_value=""
		#echo "	pkgdesc = $origdesc"
	fi

	####
	# Run function in sandbox
	unset -v depends optdepends replaces conflicts provides install license
	{
		# comandos mas comunes
		arch-meson() { :; };
		cd() { :; };
		cp() { :; };
		cmake() { :; };
		diff(){ :; };
		find(){ :; };
		file(){ :; };
		install() { :; };
		make() { :; };
		meson() { :; };
		mkdir() { :; };
		mv() { :; };
		ln() { :; };
		patch(){ :; };
		rm() { :; };
		strip() { :; };
		# funciones personalizadas
		_install_component() { :; };
		_pick() { :; }
		
		pkgdir="/tmp/pkgdir"; srcdir="/tmp/srcdir"; _archive="/tmp/archive"; startdir="/tmp/startdir"; file="/tmp/file"; builddir="/tmp/builddir"
        
        "package_$package" 2>/dev/null
    }
	####
	# --------- get license ---------
    readarray -t _new_lic < <(
        "package_$package" 2>/dev/null
        if declare -p license &>/dev/null 2>&1; then
            printf '%s\n' "${license[@]}"
        fi
    )
    local_license=()
    if [[ ${#_new_lic[@]} -gt 0 ]]; then
        if [[ ${#_new_lic[@]} -eq 1 && -z "${_new_lic[0]}" ]]; then
            local_license=()
        else
            local_license=( "${_new_lic[@]}" )
        fi
    fi
    print_array_field "	license" "license"
	
	# --------- get install ---------
    readarray -t _new_ins < <(
        "package_$package" 2>/dev/null
        if declare -p install &>/dev/null 2>&1; then
            printf '%s\n' "${install[@]}"
        fi
    )
    local_install=()
    if [[ ${#_new_ins[@]} -gt 0 ]]; then
        if [[ ${#_new_ins[@]} -eq 1 && -z "${_new_ins[0]}" ]]; then
            local_install=()
        else
            local_install=( "${_new_ins[@]}" )
        fi
    fi
    print_array_field "	install" "local_install"
	
	# --------- get depends ---------
    readarray -t _new_deps < <(
        "package_$package" 2>/dev/null
        if declare -p depends &>/dev/null 2>&1; then
            printf '%s\n' "${depends[@]}"
        fi
    )
    local_depends=()
    if [[ ${#_new_deps[@]} -gt 0 ]]; then
        if [[ ${#_new_deps[@]} -eq 1 && -z "${_new_deps[0]}" ]]; then
            local_depends=()
        else
            local_depends=( "${_new_deps[@]}" )
        fi
    fi
    print_array_field "	depends" "local_depends"
    
    # --------- get optdepends ---------
    readarray -t _new_odeps < <(
        "package_$package" 2>/dev/null
        if declare -p optdepends &>/dev/null 2>&1; then
            printf '%s\n' "${optdepends[@]}"
        fi
    )
    local_optdepends=()
    if [[ ${#_new_odeps[@]} -gt 0 ]]; then
        if [[ ${#_new_odeps[@]} -eq 1 && -z "${_new_odeps[0]}" ]]; then
            local_optdepends=()
        else
            local_optdepends=( "${_new_odeps[@]}" )
        fi
    fi
    print_array_field "	optdepends" "local_optdepends"
    
    # --------- get conflicts ---------
    readarray -t _new_conf < <(
        "package_$package" 2>/dev/null
        if declare -p conflicts &>/dev/null 2>&1; then
            printf '%s\n' "${conflicts[@]}"
        fi
    )
    local_conflicts=()
    if [[ ${#_new_conf[@]} -gt 0 ]]; then
        if [[ ${#_new_conf[@]} -eq 1 && -z "${_new_conf[0]}" ]]; then
            local_conflicts=()
        else
            local_conflicts=( "${_new_conf[@]}" )
        fi
    fi
    print_array_field "	conflicts" "local_conflicts"
    
    # --------- get replaces ---------
    readarray -t _new_reps < <(
        "package_$package" 2>/dev/null
        if declare -p replaces &>/dev/null 2>&1; then
            printf '%s\n' "${replaces[@]}"
        fi
    )
    local_replaces=()
    if [[ ${#_new_reps[@]} -gt 0 ]]; then
        if [[ ${#_new_reps[@]} -eq 1 && -z "${_new_reps[0]}" ]]; then
            local_replaces=()
        else
            local_replaces=( "${_new_reps[@]}" )
        fi
    fi
    print_array_field "	replaces" "local_replaces"
    
    # --------- get provides ---------
    readarray -t _new_prov < <(
        "package_$package" 2>/dev/null
        if declare -p provides &>/dev/null 2>&1; then
            printf '%s\n' "${provides[@]}"
        fi
    )
    local_provides=()
    if [[ ${#_new_prov[@]} -gt 0 ]]; then
        if [[ ${#_new_prov[@]} -eq 1 && -z "${_new_prov[0]}" ]]; then
            local_provides=()
        else
            local_provides=( "${_new_prov[@]}" )
        fi
    fi
    print_array_field "	provides" "provides"
    
    ############
	echo ""
	done
else
	cat <<EOF
pkgname = $pkgname
EOF
fi
# Fin del archivo .SRCINFO
}
# Argumento --printsrcinfo: imprimir y salir
if [[ "$printsrcinfo" == true ]]; then
    generate_srcinfo
    exit 0
fi

#####
# Generar .PKGINFO
#####
generate_pkginfo() {
# Inicio del archivo .PKGINFO   
	cat <<EOF
# Generated by $(basename $0)
pkgname = $pkgname
pkgbase = ${pkgbase:-$pkgname}
xdata = pkgtype=pkg
pkgver = $pkgver-$pkgrel
pkgdesc = $pkgdesc
url = $url
builddate = $BUILDDATE
packager = ${packager:-$(echo "Unknow Packager")}
size = $(echo $(du -sb "$PKGDIR" | cut -f1))
arch = $CARCH
EOF
print_array_field "license" "license"
print_array_field "depend" "depends"
print_array_field "optdepend" "optdepends"
print_array_field "makedepend" "makedepends"
print_array_field "provides" "provides"
print_array_field "conflicts" "conflicts"
print_array_field "replaces" "replaces"
# Fin del archivo .PKGINFO   
}
#####
# Generar .BUILDINFO
#####
generate_pkgbuild() {
# Inicio del archivo .BUILDINFO   
	cat  <<EOF
format = 2
pkgname = $pkgname
pkgbase = ${pkgbase:-$pkgname}
pkgver = $pkgver-$pkgrel
pkgarch = $CARCH
pkgbuild_sha256sum = $PKGBUILDSHA256
packager = ${packager:-$(whoami)}
builddate = $BUILDDATE
builddir = $workdir
startdir = $workdir
buildtool = $(basename $0)
buildtoolver = $ver
EOF
print_array_field "buildenv" "BUILDENV"
print_array_field "options" "OPTIONS"
# Fin del archivo .BUILDINFO   
}

# Validar metadatos básicos
[[ -z ${pkgname:-} ]] && error "pkgname no definido."
[[ -z ${pkgver:-} ]] && error "pkgver no definido."
[[ -z ${pkgrel:-} ]] && error "pkgrel no definido."

pkgfile="${pkgname}-${pkgver}-${pkgrel}-${CARCH}${PKGEXT}"

# Limpiar entorno
log "Limpiando directorios anteriores..."
rm -rf "$SRCDIR" "$BUILDDIR" "$PKGDIR"
mkdir -p "$SRCDIR" "$BUILDDIR" "$PKGDIR"

# ============================
# FUNCIÓN: verificar checksums
# ============================
# Verifica sha256, sha512 o b2 (blake2b) para el archivo dado.
# Usa arrays declaradas en PKGBUILD (sha256sums, sha512sums, b2sums,
# y sus variantes por arquitectura sha256sums_x86_64, etc.)
#
# Recibe:
#   $1 -> ruta completa del archivo en SRCDIR (o directo si es local)
#   $2 -> la entrada original de source (ej: "foo.tar.gz" o "name::https://...")
verify_checksum() {
    local filepath="$1"
    local srcentry="$2"

    # Si se pidió saltar verificaciones
    if [[ "$skipchecksums" == true ]]; then
        log "Saltando verificación de checksums para $filepath (opción --skipchecksums)"
        return 0
    fi

    # Si no existe el archivo regular (por ejemplo un repositorio clonado -> directorio), saltar
    if [[ ! -f "$filepath" ]]; then
        log "No es un fichero regular, saltando checksum: $filepath"
        return 0
    fi

    # Determinar el índice de la entrada dentro de la(s) arrays de source.
    local idx=-1
    local srcarray=""
    # Buscar en source[]
    if [[ -v source ]]; then
        for i in "${!source[@]}"; do
            if [[ "${source[$i]}" == "$srcentry" ]]; then
                idx=$i
                srcarray="source"
                break
            fi
        done
    fi
    # Si no encontrado, buscar en source_x86_64 o source_aarch64 si aplicable
    if [[ $idx -eq -1 && "$CARCH" == "x86_64" && -v source_x86_64 ]]; then
        for i in "${!source_x86_64[@]}"; do
            if [[ "${source_x86_64[$i]}" == "$srcentry" ]]; then
                idx=$i
                srcarray="source_x86_64"
                break
            fi
        done
    fi
    if [[ $idx -eq -1 && "$CARCH" == "aarch64" && -v source_aarch64 ]]; then
        for i in "${!source_aarch64[@]}"; do
            if [[ "${source_aarch64[$i]}" == "$srcentry" ]]; then
                idx=$i
                srcarray="source_aarch64"
                break
            fi
        done
    fi

    # Si no se encontró la entrada, informar y omitir verificación
    if [[ $idx -eq -1 ]]; then
        log "No se encontró la entrada correspondiente en arrays source[] para: $srcentry — omitiendo checksum."
        return 0
    fi

    # Obtener suma esperada (priorizar arrays por arquitectura cuando corresponda)
    local expected=""
    # helper para obtener elemento seguro
    _arr_get() {
        local arrname="$1"; local pos="$2"
        if eval '[[ -v '"$arrname"' ]]' 2>/dev/null; then
            eval "local -a __a=(\"\${${arrname}[@]}\")"
            if [[ $pos -ge 0 && $pos -lt ${#__a[@]} ]]; then
                echo "${__a[$pos]}"
                return 0
            fi
        fi
        return 1
    }

    if [[ "${srcarray}" == "source_x86_64" ]]; then
        # primero las sums específicas de x86_64
        expected="$(_arr_get sha256sums_x86_64 "$idx")" || true
        if [[ -z "$expected" ]]; then expected="$(_arr_get sha512sums_x86_64 "$idx")" || true; fi
        if [[ -z "$expected" ]]; then expected="$(_arr_get b2sums_x86_64 "$idx")" || true; fi

        # fallback a genérico si no hay específica
        if [[ -z "$expected" ]]; then
            expected="$(_arr_get sha256sums "$idx")" || true
            if [[ -z "$expected" ]]; then expected="$(_arr_get sha512sums "$idx")" || true; fi
            if [[ -z "$expected" ]]; then expected="$(_arr_get b2sums "$idx")" || true; fi
        fi

    elif [[ "${srcarray}" == "source_aarch64" ]]; then
        # primero las sums específicas de aarch64
        expected="$(_arr_get sha256sums_aarch64 "$idx")" || true
        if [[ -z "$expected" ]]; then expected="$(_arr_get sha512sums_aarch64 "$idx")" || true; fi
        if [[ -z "$expected" ]]; then expected="$(_arr_get b2sums_aarch64 "$idx")" || true; fi

        # fallback a genérico si no hay específica
        if [[ -z "$expected" ]]; then
            expected="$(_arr_get sha256sums "$idx")" || true
            if [[ -z "$expected" ]]; then expected="$(_arr_get sha512sums "$idx")" || true; fi
            if [[ -z "$expected" ]]; then expected="$(_arr_get b2sums "$idx")" || true; fi
        fi

    else
        # Caso por defecto: arrays genéricos
        expected="$(_arr_get sha256sums "$idx")" || true
        if [[ -z "$expected" ]]; then expected="$(_arr_get sha512sums "$idx")" || true; fi
        if [[ -z "$expected" ]]; then expected="$(_arr_get b2sums "$idx")" || true; fi
    fi

    # Si no hay suma esperada o es "SKIP", saltar
    if [[ -z "$expected" || "$expected" == "SKIP" || "$expected" == $'SKIP\n' ]]; then
        log "No hay checksum declarado (o es SKIP) para $filepath — se omite verificación."
        return 0
    fi

    # Normalizar expected (puede venir con espacios)
    expected="$(echo -n "$expected" | tr -d '[:space:]')"

    # Calcular sumas disponibles
    local computed=""
    if command -v sha256sum >/dev/null 2>&1; then
        computed="$(sha256sum "$filepath" | awk '{print $1}')"
        if [[ "$computed" == "$expected" ]]; then
            log "sha256 OK: $(basename "$filepath")"
            return 0
        fi
    fi

    if command -v sha512sum >/dev/null 2>&1; then
        computed="$(sha512sum "$filepath" | awk '{print $1}')"
        if [[ "$computed" == "$expected" ]]; then
            log "sha512 OK: $(basename "$filepath")"
            return 0
        fi
    fi

    # b2sum (blake2b)
    if command -v b2sum >/dev/null 2>&1; then
        computed="$(b2sum "$filepath" | awk '{print $1}')"
        if [[ "$computed" == "$expected" ]]; then
            log "b2 (blake2b) OK: $(basename "$filepath")"
            return 0
        fi
    fi

    # Si llegamos acá, ninguna coincide
    error "Checksum mismatch para $(basename "$filepath"). Esperado: $expected. Computado: $computed"
}

# === FUNCIÓN: descargar o copiar fuente ===
download_source() {
    local src="$1"
    local filename url

    # Si usa alias con '::', separar el nombre local y la URL real
    if [[ "$src" == *::* ]]; then
        filename="${src%%::*}"   # parte antes de '::'
        url="${src#*::}"         # parte después de '::'
    else
        filename="${src##*/}"    # por defecto, tomar el nombre del archivo de la URL
        url="$src"
    fi

    # Si no hay protocolo, es archivo local
    if [[ "$url" != *://* ]]; then
        [[ -f "$url" ]] || error "Archivo local no encontrado: $url"
        log "Copiando archivo local: $url → $filename"
        cp "$url" "$SRCDIR/$filename"
        # Verificar checksum del archivo copiado (si aplica)
        verify_checksum "$SRCDIR/$filename" "$src"
        return
    fi

    # Descarga vía HTTPS
    if [[ "$url" == http*://* ]]; then
        log "Descargando: $url → $filename"
        if command -v curl >/dev/null; then
            curl -Lf -o "$SRCDIR/$filename" "$url"
        elif command -v wget >/dev/null; then
            wget -O "$SRCDIR/$filename" "$url"
        else
            error "Necesitas curl o wget para descargar."
        fi
	# Verificar checksum del archivo descargado (si aplica)
	    verify_checksum "$SRCDIR/$filename" "$src"
    # Repositorios Git
    elif [[ "$url" == git+https://* ]]; then
        local full_url="${url#git+}"
        # url_base = parte antes de '#' (el repo real)
        local url_base="${full_url%%#*}"
        local fragment="${full_url#*#}"
        # repo_name extraído del url_base para evitar fragmentos como '#tag=...'
        local repo_name="${url_base##*/}"
        repo_name="${repo_name%.git}"

        if [[ "$fragment" == tag=* ]]; then
            local tag="${fragment#tag=}"
            log "Clonando etiqueta '$tag' de: $url_base"
            git clone --depth=1 --branch "$tag" "$url_base" "$SRCDIR/$repo_name"
        elif [[ "$fragment" == branch=* ]]; then
            local branch="${fragment#branch=}"
            log "Clonando rama '$branch' de: $url_base"
            git clone --depth=1 --branch "$branch" "$url_base" "$SRCDIR/$repo_name"
        else
            log "Clonando repositorio por defecto: $url_base"
            git clone --depth=1 "$url_base" "$SRCDIR/$repo_name"
        fi
    else
        error "Fuente no soportada: $src (solo local, http://, https://, git+https://)"
    fi
}

# === FUNCIÓN: extraer archivos comprimidos ===
extract_sources() {
    local extracted=false
    local -a skiplist
    local -a files

    # Asegurar SRCDIR por defecto (igual que makepkg)
    SRCDIR="${SRCDIR:-${PWD}/src}"
    mkdir -p "$SRCDIR"

    # Si noextract está definido, guardamos los nombres a omitir
    if [[ -v noextract && ${#noextract[@]} -gt 0 ]]; then
        skiplist=( "${noextract[@]}" )
    fi

    # Tomar "foto" de los archivos que hay ahora en SRCDIR para evitar procesar artefactos creados durante la extracción
    # Usamos nullglob en una subshell para evitar cambiar el shell globalmente
    readarray -t files < <(
        bash -c 'shopt -s nullglob; for f in "$1"/*; do printf "%s\n" "$f"; done' -- "$SRCDIR"
    )

    for f in "${files[@]}"; do
        [[ -e "$f" ]] || continue
        local filename=$(basename "$f")

        # Sólo procesar archivos regulares (evitar directorios)
        if [[ ! -f "$f" ]]; then
            log "Saltando $filename (no es archivo regular)"
            continue
        fi

        # Omitir si está en noextract[]
        if [[ " ${skiplist[*]} " == *" ${filename} "* ]]; then
            log "Omitiendo extracción de $filename (noextract)"
            continue
        fi

        case "$f" in
            *.tar.gz|*.tgz)
                log "Extrayendo $filename"
                tar -xzf "$f" -C "$SRCDIR" || { log "ERROR: falló tar -xzf $filename"; return 1; }
                extracted=true
                ;;
            *.tar.xz|*.txz)
                log "Extrayendo $filename"
                tar -xJf "$f" -C "$SRCDIR" || { log "ERROR: falló tar -xJf $filename"; return 1; }
                extracted=true
                ;;
            *.tar.bz2|*.tbz2)
                log "Extrayendo $filename"
                tar -xjf "$f" -C "$SRCDIR" || { log "ERROR: falló tar -xjf $filename"; return 1; }
                extracted=true
                ;;
            *.tar.zst)
                log "Extrayendo $filename"
                if ! command -v zstd >/dev/null 2>&1; then
                    log "ERROR: zstd no está disponible para descomprimir $filename"
                    return 1
                fi
                zstd -dc "$f" | tar -xf - -C "$SRCDIR" || { log "ERROR: falló descompresión zstd|tar para $filename"; return 1; }
                extracted=true
                ;;
            *.zip)
                log "Extrayendo $filename"
                if ! command -v unzip >/dev/null 2>&1; then
                    log "ERROR: unzip no está disponible para descomprimir $filename"
                    return 1
                fi
                unzip -q "$f" -d "$SRCDIR" || { log "ERROR: falló unzip $filename"; return 1; }
                extracted=true
                ;;
            *.deb)
				log "Extrayendo $filename"
				bsdtar -xf "$f" -C "$SRCDIR" || { log "ERROR: falló bsdtar -xf $filename"; return 1; }
				extracted=true
				;;
            *)
                log "Saltando $filename (tipo desconocido o no comprimido)"
                ;;
        esac
    done

    if [[ "$extracted" == false ]]; then
        log "No se extrajeron archivos (todos estaban en noextract o no eran comprimidos)."
    else
        # Mostrar árbol resultante para facilitar debugging (igual que makepkg suele listar)
        #log "Contenido de $SRCDIR tras la extracción:"
        #find "$SRCDIR" -maxdepth 3 -mindepth 1 -print || true
        echo ""
    fi
}


# === PROCESO PRINCIPAL ===

log "Descargando fuentes..."
# Iterar sobre source[]
if [[ -v source && ${#source[@]} -gt 0 ]]; then
    for src in "${source[@]}"; do
        download_source "$src"
    done
fi

# Iterar sobre source_x86_64[]
if [[ "$CARCH" == "x86_64" && -v source_x86_64 && ${#source_x86_64[@]} -gt 0 ]]; then
    for src in "${source_x86_64[@]}"; do
        download_source "$src"
    done
fi

# Iterar sobre source_aarch64[]
if [[ "$CARCH" == "aarch64" && -v source_aarch64 && ${#source_aarch64[@]} -gt 0 ]]; then
    for src in "${source_aarch64[@]}"; do
        download_source "$src"
    done
fi

extract_sources

# Ejecutar prepare()
if declare -f prepare >/dev/null; then
    log "Ejecutando prepare()..."
    (
        export srcdir="$SRCDIR"
        export pkgdir="$PKGDIR"
        export startdir="$PWD"
        cd "$SRCDIR"
        prepare
    )
fi

# Ejecutar build()
if declare -f build >/dev/null; then
    log "Ejecutando build()..."
    (
        export srcdir="$SRCDIR"
        export pkgdir="$PKGDIR"
        export startdir="$PWD"
        cd "$BUILDDIR"
        # Enlazar fuentes
        for item in "$SRCDIR"/*; do
            [[ -e "$item" ]] || continue
            ln -sf "$item" .
        done
        build
    )
else
    log "No se definió build(), saltando compilación (posiblemente paquete binario precompìlado)."
fi

# Ejecutar package()
if declare -f package >/dev/null; then
    log "Ejecutando package()..."

    # Si existe build(), usar $BUILDDIR, si no, usar $SRCDIR
    pkg_context="$BUILDDIR"
    if ! declare -f build >/dev/null; then
        pkg_context="$SRCDIR"
    fi

    (
        export srcdir="$SRCDIR"
        export pkgdir="$PKGDIR"
        export startdir="$PWD"
        cd "$pkg_context"
        package
    )
else
    error "Función package() no definida en PKGBUILD."
fi


# Metadatos mínimos (formato compatible con pacman, sin makedepends)
log "Generando metadatos (.PKGINFO)..."
generate_pkginfo > "$PKGDIR/.PKGINFO"
log "Generando metadatos (.BUILDINFO)..."
generate_pkgbuild > "$PKGDIR/.BUILDINFO"

# .MTREE (mejor compatibilidad con pacman)
if command -v bsdtar >/dev/null; then
    log "Generando .MTREE..."
    (cd "$PKGDIR" && bsdtar -czf .MTREE --format=mtree --options='!all,use-set,uid,gid,mode,time,size,sha256,link' . 2>/dev/null)
else
    log "Advertencia: bsdtar no encontrado. El paquete no tendrá .MTREE."
fi

if [[ "$noarchive" == true ]]; then
    log "Opción --noarchive activada: se omite la creación del paquete."
    log "${GREEN}Build completado sin generar .pkg.tar.zst${NC}"
    exit 0
fi

# Empaquetar
log "Creando paquete: $pkgfile"
if command -v bsdtar >/dev/null; then
    ( cd "$PKGDIR" && \
      find . -mindepth 1 -maxdepth 1 -printf '%P\0' | \
      bsdtar -c --zstd -f "$workdir/$pkgfile" --null -T - ) || {
        log "Error: falló bsdtar"
        exit 1
    }
else
    ( cd "$PKGDIR" && \
      find . -mindepth 1 -maxdepth 1 -printf '%P\0' | \
      tar -c --null -T - | zstd -o "$workdir/$pkgfile" ) || {
        log "Error: falló tar + zstd"
        exit 1
    }
fi

log "${GREEN}¡Paquete creado con éxito!${NC} -> $pkgfile"
