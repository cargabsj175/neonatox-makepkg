#!/bin/bash
set -euo pipefail

# === Opciones de línea de comandos ===
workdir="$PWD"
printsrcinfo=false

while [[ $# -gt 0 ]]; do
    case "$1" in
        -D|--dir)
            if [[ -z "${2:-}" ]]; then
                echo "Error: $1 requiere un argumento." >&2
                exit 1
            fi
            workdir="$2"
            shift 2
            ;;
        --printsrcinfo)
            printsrcinfo=true
            shift
            ;;
        *)
            echo "Opción desconocida: $1" >&2
            exit 1
            ;;
    esac
done

# Cambiar al directorio especificado
cd "$workdir"

# Directorios de trabajo (relativos al directorio de trabajo)
readonly SRCDIR="$PWD/src"
readonly BUILDDIR="$PWD/build"
readonly PKGDIR="$PWD/pkg"
readonly PKGEXT=".pkg.tar.zst"
readonly CARCH="$(uname -m)"

# Colores
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m'

log() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
    exit 1
}

# Verificar PKGBUILD
[[ -f PKGBUILD ]] || error "PKGBUILD not found."

# Variables generales
PKGBUILDSHA256=$(sha256sum PKGBUILD | sed 's/ PKGBUILD//g')
BUILDDATE=$(date +%s)
PACKAGETYPE=$(cat PKGBUILD | grep package | sed 's/ {//g')

log "Cargando PKGBUILD..."
source PKGBUILD

# Verificar la condición
if [ "$PACKAGETYPE" != "package()" ]; then
    echo "Error: $(basename $0) only supports non-split PKGBUILD files..."
    exit 1
fi

##############################
# Funciones para metapaquetes
##############################
generate_srcinfo() {
    # Función auxiliar para imprimir array en formato SRCINFO
    print_array_field() {
        local field="$1"
        local var="$2"
        if ! eval '[[ -v '"$var"' ]]' 2>/dev/null; then
            return
        fi
        eval 'local values=("${'"$var"'[@]}")'
        for val in "${values[@]}"; do
            [[ -n "$val" ]] && echo "	$field = $val"
        done
    }
    cat <<EOF
pkgbase = ${pkgbase:-$pkgname}
	pkgdesc = $pkgdesc
	url = $url
EOF
	print_array_field "arch" "arch"
	cat <<EOF
	pkgver = $pkgver
	pkgrel = $pkgrel
	epoch = ${epoch:-1}
	packager = ${packager:-$(whoami)}
EOF
    # Campos opcionales
    print_array_field "license" "license"
    print_array_field "makedepends" "makedepends"
    print_array_field "depends" "depends"
    print_array_field "optdepends" "optdepends"
    print_array_field "provides" "provides"
    print_array_field "conflicts" "conflicts"
    print_array_field "noextract" "noextract"
    print_array_field "options" "options"
    print_array_field "replaces" "replaces"
    # Fuentes (simple)
    for src in "${source[@]}"; do
        echo "	source = $src"
    done
    print_array_field "sha256sums" "sha256sums"
    print_array_field "b2sums" "b2sums"
    # Fuentes (x86_64)
    for src in "${source_x86_64[@]}"; do
        echo "	source_x86_64 = $src"
    done
    print_array_field "sha256sums_x86_64" "sha256sums_x86_64"
    # Fuentes (aarch64)
    for src in "${source_aarch64[@]}"; do
        echo "	source_aarch64 = $src"
    done
    print_array_field "sha256sums_aarch64" "sha256sums_aarch64"
    cat <<EOF

pkgname = $pkgname
EOF
}

# Modo --printsrcinfo: imprimir y salir
if [[ "$printsrcinfo" == true ]]; then
    generate_srcinfo
    exit 0
fi

generate_pkginfo() {
	cat <<EOF
# Generated by $(basename $0)
pkgname = $pkgname
pkgbase = ${pkgbase:-$pkgname}
xdata = pkgtype=pkg
pkgver = $pkgver-$pkgrel
pkgdesc = $pkgdesc
url = $url
builddate = $BUILDDATE
packager = ${packager:-$(whoami)}
size = $(echo $(du -sb "$PKGDIR" | cut -f1))
arch = $(uname -m)
EOF

# Función auxiliar: escribe un campo que puede ser array o string
write_pkginfo_array_field() {
    local field_name="$1"
    local var_name="$2"

    # Si la variable no está definida, salir
    if ! eval '[[ -v '"$var_name"' ]]' >/dev/null 2>&1; then
        return
    fi

    # Extraer valores (funciona tanto para arrays como para strings)
    eval 'local _vals=("${'"$var_name"'[@]}")'

    for _v in "${_vals[@]}"; do
        # Saltar elementos vacíos
        [[ -n "$_v" ]] || continue
        # Si el campo es optdepends y el elemento contiene ':' o ' - ', dejar tal cual (ej: "pkg: descripción")
        echo "$field_name = $_v" >> "$PKGDIR/.PKGINFO"
    done
}

# Campos en el orden deseado por pacman (salteables si no existen)
# license (puede ser array o string)
write_pkginfo_array_field "license" "license"
# depends
write_pkginfo_array_field "depend" "depends"
# optdepends (opcional)
write_pkginfo_array_field "optdepend" "optdepends"
# makedepends (opcional)
write_pkginfo_array_field "makedepend" "makedepends"
# provides, conflicts, replaces (cada uno opcional)
write_pkginfo_array_field "provides" "provides"
write_pkginfo_array_field "conflicts" "conflicts"
write_pkginfo_array_field "replaces" "replaces"
	}

generate_pkgbuild() {
	cat  <<EOF
format = 2
pkgname = $pkgname
pkgbase = ${pkgbase:-$pkgname}
pkgver = $pkgver-$pkgrel
pkgarch = $(uname -m)
pkgbuild_sha256sum = $PKGBUILDSHA256
packager = ${packager:-$(whoami)}
builddate = $BUILDDATE
builddir = $workdir
startdir = $workdir
buildtool = $(basename $0)
buildtoolver = 0.5
buildenv = !distcc
buildenv = color
buildenv = !ccache
buildenv = check
buildenv = !sign
options = strip
options = docs
options = !libtool
options = !staticlibs
options = emptydirs
options = zipman
options = purge
options = debug
options = lto
EOF
	}


# Validar metadatos básicos
[[ -z ${pkgname:-} ]] && error "pkgname no definido."
[[ -z ${pkgver:-} ]] && error "pkgver no definido."
[[ -z ${pkgrel:-} ]] && error "pkgrel no definido."

readonly pkgfile="${pkgname}-${pkgver}-${pkgrel}${PKGEXT}"

# Limpiar entorno
log "Limpiando directorios anteriores..."
rm -rf "$SRCDIR" "$BUILDDIR" "$PKGDIR"
mkdir -p "$SRCDIR" "$BUILDDIR" "$PKGDIR"

# === FUNCIÓN: descargar o copiar fuente ===
download_source() {
    local src="$1"
    local filename url

    # Si usa alias con '::', separar el nombre local y la URL real
    if [[ "$src" == *::* ]]; then
        filename="${src%%::*}"   # parte antes de '::'
        url="${src#*::}"         # parte después de '::'
    else
        filename="${src##*/}"    # por defecto, tomar el nombre del archivo de la URL
        url="$src"
    fi

    # Si no hay protocolo, es archivo local
    if [[ "$url" != *://* ]]; then
        [[ -f "$url" ]] || error "Archivo local no encontrado: $url"
        log "Copiando archivo local: $url → $filename"
        cp "$url" "$SRCDIR/$filename"
        return
    fi

    # Descarga vía HTTPS
    if [[ "$url" == https://* ]]; then
        log "Descargando: $url → $filename"
        if command -v curl >/dev/null; then
            curl -Lf -o "$SRCDIR/$filename" "$url"
        elif command -v wget >/dev/null; then
            wget -O "$SRCDIR/$filename" "$url"
        else
            error "Necesitas curl o wget para descargar."
        fi

    # Repositorios Git
    elif [[ "$url" == git+https://* ]]; then
        local full_url="${url#git+}"
        # url_base = parte antes de '#' (el repo real)
        local url_base="${full_url%%#*}"
        local fragment="${full_url#*#}"
        # repo_name extraído del url_base para evitar fragmentos como '#tag=...'
        local repo_name="${url_base##*/}"
        repo_name="${repo_name%.git}"

        if [[ "$fragment" == tag=* ]]; then
            local tag="${fragment#tag=}"
            log "Clonando etiqueta '$tag' de: $url_base"
            git clone --depth=1 --branch "$tag" "$url_base" "$SRCDIR/$repo_name"
        elif [[ "$fragment" == branch=* ]]; then
            local branch="${fragment#branch=}"
            log "Clonando rama '$branch' de: $url_base"
            git clone --depth=1 --branch "$branch" "$url_base" "$SRCDIR/$repo_name"
        else
            log "Clonando repositorio por defecto: $url_base"
            git clone --depth=1 "$url_base" "$SRCDIR/$repo_name"
        fi
    else
        error "Fuente no soportada: $src (solo local, https://, git+https://)"
    fi
}


# === FUNCIÓN: extraer archivos comprimidos ===
extract_sources() {
    local extracted=false
    local skiplist=()

    # Si noextract está definido, guardamos los nombres a omitir
    if [[ -v noextract && ${#noextract[@]} -gt 0 ]]; then
        skiplist=("${noextract[@]}")
    fi

    for f in "$SRCDIR"/*; do
        [[ -e "$f" ]] || continue
        local filename=$(basename "$f")

        # Omitir si está en noextract[]
        if [[ " ${skiplist[*]} " == *" ${filename} "* ]]; then
            log "Omitiendo extracción de $filename (noextract)"
            continue
        fi

        case "$f" in
            *.tar.gz|*.tgz)
                log "Extrayendo $filename"
                tar -xzf "$f" -C "$SRCDIR"
                extracted=true
                ;;
            *.tar.xz|*.txz)
                log "Extrayendo $filename"
                tar -xJf "$f" -C "$SRCDIR"
                extracted=true
                ;;
            *.tar.bz2|*.tbz2)
                log "Extrayendo $filename"
                tar -xjf "$f" -C "$SRCDIR"
                extracted=true
                ;;
            *.tar.zst)
                log "Extrayendo $filename"
                zstd -dc "$f" | tar -xf - -C "$SRCDIR"
                extracted=true
                ;;
            *.zip)
                log "Extrayendo $filename"
                unzip -q "$f" -d "$SRCDIR"
                extracted=true
                ;;
            *)
                log "Saltando $filename (tipo desconocido o no comprimido)"
                ;;
        esac
    done

    [[ "$extracted" == false ]] && log "No se extrajeron archivos (todos estaban en noextract o no eran comprimidos)."
}

# === PROCESO PRINCIPAL ===

log "Descargando fuentes..."
# Iterar sobre source[]
if [[ -v source && ${#source[@]} -gt 0 ]]; then
    for src in "${source[@]}"; do
        download_source "$src"
    done
fi

# Iterar sobre source_x86_64[]
if [[ "$CARCH" == "x86_64" && -v source_x86_64 && ${#source_x86_64[@]} -gt 0 ]]; then
    for src in "${source_x86_64[@]}"; do
        download_source "$src"
    done
fi

# Iterar sobre source_aarch64[]
if [[ "$CARCH" == "aarch64" && -v source_aarch64 && ${#source_aarch64[@]} -gt 0 ]]; then
    for src in "${source_aarch64[@]}"; do
        download_source "$src"
    done
fi

extract_sources

# Ejecutar prepare()
if declare -f prepare >/dev/null; then
    log "Ejecutando prepare()..."
    (
        export srcdir="$SRCDIR"
        export pkgdir="$PKGDIR"
        export startdir="$PWD"
        cd "$SRCDIR"
        prepare
    )
fi

# Ejecutar build()
if declare -f build >/dev/null; then
    log "Ejecutando build()..."
    (
        export srcdir="$SRCDIR"
        export pkgdir="$PKGDIR"
        export startdir="$PWD"
        cd "$BUILDDIR"
        # Enlazar fuentes
        for item in "$SRCDIR"/*; do
            [[ -e "$item" ]] || continue
            ln -sf "$item" .
        done
        build
    )
else
    log "No se definió build(), saltando compilación (posiblemente paquete binario precompìlado)."
fi

# Ejecutar package()
if declare -f package >/dev/null; then
    log "Ejecutando package()..."

    # Si existe build(), usar $BUILDDIR, si no, usar $SRCDIR
    pkg_context="$BUILDDIR"
    if ! declare -f build >/dev/null; then
        pkg_context="$SRCDIR"
    fi

    (
        export srcdir="$SRCDIR"
        export pkgdir="$PKGDIR"
        export startdir="$PWD"
        cd "$pkg_context"
        package
    )
else
    error "Función package() no definida en PKGBUILD."
fi


# Metadatos mínimos (formato compatible con pacman, sin makedepends)
log "Generando metadatos (.PKGINFO)..."
generate_pkginfo > "$PKGDIR/.PKGINFO"

log "Generando metadatos (.BUILDINFO)..."
generate_srcinfo > "$PKGDIR/.BUILDINFO"


# .MTREE (mejor compatibilidad con pacman)
if command -v bsdtar >/dev/null; then
    log "Generando .MTREE..."
    (cd "$PKGDIR" && bsdtar -czf .MTREE --format=mtree --options='!all,use-set,uid,gid,mode,time,size,sha256,link' . 2>/dev/null)
else
    log "Advertencia: bsdtar no encontrado. El paquete no tendrá .MTREE."
fi

# Empaquetar
log "Creando paquete: $pkgfile"
if command -v bsdtar >/dev/null; then
    ( cd "$PKGDIR" && \
      find . -mindepth 1 -maxdepth 1 -printf '%P\0' | \
      bsdtar -c --zstd -f "$pkgfile" --null -T - ) || {
        log "Error: falló bsdtar"
        exit 1
    }
else
    ( cd "$PKGDIR" && \
      find . -mindepth 1 -maxdepth 1 -printf '%P\0' | \
      tar -c --null -T - | zstd -o "$pkgfile" ) || {
        log "Error: falló tar + zstd"
        exit 1
    }
fi


log "${GREEN}¡Paquete creado con éxito!${NC} -> $pkgfile"
